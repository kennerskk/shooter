<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Multiplayer Bird Eye Shooter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #0c0c0c, #1a1a2e);
      font-family: 'Courier New', monospace;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      color: #fff;
      overflow: hidden;
    }
    
    #gameContainer {
      text-align: center;
      position: relative;
    }
    
    canvas {
      background: radial-gradient(circle at center, #111, #000);
      display: block;
      border: 2px solid #333;
      border-radius: 10px;
      box-shadow: 0 0 30px rgba(0, 255, 0, 0.3);
      cursor: crosshair;
    }
    
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #333;
      min-width: 200px;
      font-size: 14px;
    }
    
    #playerStats {
      margin-bottom: 10px;
      padding-bottom: 10px;
      border-bottom: 1px solid #333;
    }
    
    #leaderboard {
      max-height: 150px;
      overflow-y: auto;
    }
    
    .player-stat {
      display: flex;
      justify-content: space-between;
      margin: 2px 0;
      font-size: 12px;
    }
    
    .player-name {
      color: #0f0;
    }
    
    .current-player {
      color: #ff0;
      font-weight: bold;
    }
    
    #controls {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #333;
      font-size: 12px;
      color: #aaa;
    }
    
    .control-key {
      background: #333;
      padding: 2px 6px;
      border-radius: 3px;
      margin: 0 2px;
      color: #0f0;
    }
    
    #connectionStatus {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 8px 12px;
      border-radius: 5px;
      font-size: 12px;
      font-weight: bold;
    }
    
    .connected {
      background: rgba(0, 255, 0, 0.2);
      border: 1px solid #0f0;
      color: #0f0;
    }
    
    .disconnected {
      background: rgba(255, 0, 0, 0.2);
      border: 1px solid #f00;
      color: #f00;
    }
    
    #respawnMessage {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 0, 0, 0.9);
      padding: 20px;
      border-radius: 10px;
      border: 2px solid #f00;
      display: none;
      text-align: center;
    }
    
    #chatContainer {
      position: absolute;
      bottom: 10px;
      right: 10px;
      width: 250px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 8px;
      border: 1px solid #333;
      padding: 10px;
    }
    
    #chatMessages {
      height: 100px;
      overflow-y: auto;
      margin-bottom: 10px;
      font-size: 12px;
      border: 1px solid #333;
      padding: 5px;
      background: rgba(0, 0, 0, 0.5);
    }
    
    #chatInput {
      width: 100%;
      background: #333;
      border: 1px solid #555;
      color: #fff;
      padding: 5px;
      border-radius: 3px;
      font-size: 12px;
    }
    
    .chat-message {
      margin: 2px 0;
    }
    
    .system-message {
      color: #888;
      font-style: italic;
    }
    
    .kill-message {
      color: #f0f;
    }
    
    @media (max-width: 900px) {
      canvas {
        width: 90vw;
        height: 67.5vw;
      }
      
      #ui, #controls, #chatContainer {
        font-size: 10px;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div id="connectionStatus" class="disconnected">Connecting...</div>
    
    <div id="ui">
      <div id="playerStats">
        <div>Health: <span id="health">100</span></div>
        <div>Score: <span id="score">0</span></div>
        <div>K/D: <span id="kills">0</span>/<span id="deaths">0</span></div>
      </div>
      
      <div id="leaderboard">
        <div style="font-weight: bold; margin-bottom: 5px;">Players Online:</div>
        <div id="playerList"></div>
      </div>
    </div>
    
    <div id="controls">
      Move: <span class="control-key">WASD</span> | 
      Shoot: <span class="control-key">Click</span> or <span class="control-key">Space</span><br>
      Auto-aim: <span class="control-key">Hold Right Click</span>
    </div>
    
    <div id="respawnMessage">
      <h3>You were eliminated!</h3>
      <p>Respawning in <span id="respawnTimer">2</span> seconds...</p>
    </div>
    
    <div id="chatContainer">
      <div id="chatMessages"></div>
      <input type="text" id="chatInput" placeholder="Press Enter to chat..." maxlength="100">
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Game state
    let gameState = {
      players: {},
      bullets: [],
      powerUps: []
    };
    
    let myPlayer = null;
    let keys = {};
    let mousePos = { x: 0, y: 0 };
    let isMouseDown = false;
    let rightMouseDown = false;
    let lastShot = 0;
    let particles = [];
    
    // Socket events
    socket.on('connect', () => {
      document.getElementById('connectionStatus').textContent = 'Connected';
      document.getElementById('connectionStatus').className = 'connected';
      addChatMessage('Connected to server', 'system');
    });
    
    socket.on('disconnect', () => {
      document.getElementById('connectionStatus').textContent = 'Disconnected';
      document.getElementById('connectionStatus').className = 'disconnected';
      addChatMessage('Disconnected from server', 'system');
    });
    
    socket.on('gameState', (state) => {
      gameState = state;
      myPlayer = gameState.players[socket.id];
    });
    
    socket.on('gameUpdate', (update) => {
      gameState.players = update.players;
      gameState.bullets = update.bullets;
      gameState.powerUps = update.powerUps;
      myPlayer = gameState.players[socket.id];
      updateUI();
    });
    
    socket.on('playerJoined', (player) => {
      addChatMessage(`${player.id.substr(0, 6)} joined the game`, 'system');
    });
    
    socket.on('playerLeft', (playerId) => {
      addChatMessage(`${playerId.substr(0, 6)} left the game`, 'system');
    });
    
    socket.on('playerHit', (data) => {
      if (data.playerId === socket.id) {
        // I was hit
        createHitEffect(myPlayer.x, myPlayer.y, '#ff0000');
        
        if (data.died) {
          showRespawnMessage();
          addChatMessage(`You were eliminated by ${data.shooterId.substr(0, 6)}`, 'kill');
        }
      } else if (data.shooterId === socket.id) {
        // I hit someone
        const hitPlayer = gameState.players[data.playerId];
        if (hitPlayer) {
          createHitEffect(hitPlayer.x, hitPlayer.y, '#00ff00');
        }
        
        if (data.died) {
          addChatMessage(`You eliminated ${data.playerId.substr(0, 6)}`, 'kill');
        }
      }
    });
    
    socket.on('powerUpCollected', (data) => {
      if (data.playerId === socket.id) {
        addChatMessage(`Collected ${data.type} power-up!`, 'system');
      }
    });
    
    // Event listeners
    document.addEventListener('keydown', (e) => {
      keys[e.key.toLowerCase()] = true;
      
      if (e.key === ' ') {
        e.preventDefault();
        shoot();
      }
    });
    
    document.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
    });
    
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mousePos.x = (e.clientX - rect.left) * (canvas.width / rect.width);
      mousePos.y = (e.clientY - rect.top) * (canvas.height / rect.height);
    });
    
    canvas.addEventListener('mousedown', (e) => {
      if (e.button === 0) { // Left click
        isMouseDown = true;
        shoot();
      } else if (e.button === 2) { // Right click
        rightMouseDown = true;
        e.preventDefault();
      }
    });
    
    canvas.addEventListener('mouseup', (e) => {
      if (e.button === 0) {
        isMouseDown = false;
      } else if (e.button === 2) {
        rightMouseDown = false;
      }
    });
    
    canvas.addEventListener('contextmenu', (e) => {
      e.preventDefault();
    });
    
    // Chat functionality
    document.getElementById('chatInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const message = e.target.value.trim();
        if (message) {
          addChatMessage(`You: ${message}`, 'user');
          e.target.value = '';
        }
      }
    });
    
    function addChatMessage(text, type = 'normal') {
      const messagesDiv = document.getElementById('chatMessages');
      const messageDiv = document.createElement('div');
      messageDiv.className = `chat-message ${type}-message`;
      messageDiv.textContent = text;
      messagesDiv.appendChild(messageDiv);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
      
      // Remove old messages
      while (messagesDiv.children.length > 50) {
        messagesDiv.removeChild(messagesDiv.firstChild);
      }
    }
    
    // Game functions
    function updatePlayer() {
      if (!myPlayer || myPlayer.health <= 0) return;
      
      let moved = false;
      const speed = 5;
      
      if (keys['w'] && myPlayer.y > myPlayer.size) {
        myPlayer.y -= speed;
        moved = true;
      }
      if (keys['s'] && myPlayer.y < canvas.height - myPlayer.size) {
        myPlayer.y += speed;
        moved = true;
      }
      if (keys['a'] && myPlayer.x > myPlayer.size) {
        myPlayer.x -= speed;
        moved = true;
      }
      if (keys['d'] && myPlayer.x < canvas.width - myPlayer.size) {
        myPlayer.x += speed;
        moved = true;
      }
      
      if (moved) {
        socket.emit('playerMove', { x: myPlayer.x, y: myPlayer.y });
      }
      
      // Auto-aim shooting with right mouse
      if (rightMouseDown && Date.now() - lastShot > 100) {
        shoot();
      }
      
      // Check power-up collection
      gameState.powerUps.forEach(powerUp => {
        const distance = Math.sqrt(
          Math.pow(myPlayer.x - powerUp.x, 2) + Math.pow(myPlayer.y - powerUp.y, 2)
        );
        
        if (distance < myPlayer.size + 15) {
          socket.emit('collectPowerUp', powerUp.id);
        }
      });
    }
    
    function shoot() {
      if (!myPlayer || myPlayer.health <= 0 || Date.now() - lastShot < 100) return;
      
      let targetX, targetY;
      
      if (rightMouseDown) {
        // Auto-aim to nearest enemy
        let nearestEnemy = null;
        let nearestDistance = Infinity;
        
        Object.values(gameState.players).forEach(player => {
          if (player.id !== socket.id && player.health > 0) {
            const distance = Math.sqrt(
              Math.pow(myPlayer.x - player.x, 2) + Math.pow(myPlayer.y - player.y, 2)
            );
            
            if (distance < nearestDistance) {
              nearestDistance = distance;
              nearestEnemy = player;
            }
          }
        });
        
        if (nearestEnemy) {
          targetX = nearestEnemy.x;
          targetY = nearestEnemy.y;
        } else {
          return; // No targets
        }
      } else {
        targetX = mousePos.x;
        targetY = mousePos.y;
      }
      
      const angle = Math.atan2(targetY - myPlayer.y, targetX - myPlayer.x);
      
      socket.emit('playerShoot', {
        x: myPlayer.x,
        y: myPlayer.y,
        angle: angle
      });
      
      lastShot = Date.now();
      createMuzzleFlash(myPlayer.x, myPlayer.y, angle);
    }
    
    function createHitEffect(x, y, color) {
      for (let i = 0; i < 10; i++) {
        particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 6,
          vy: (Math.random() - 0.5) * 6,
          life: 1,
          decay: 0.02,
          size: Math.random() * 3 + 1,
          color: color
        });
      }
    }
    
    function createMuzzleFlash(x, y, angle) {
      for (let i = 0; i < 5; i++) {
        particles.push({
          x: x + Math.cos(angle) * 20,
          y: y + Math.sin(angle) * 20,
          vx: Math.cos(angle) * 3 + (Math.random() - 0.5) * 2,
          vy: Math.sin(angle) * 3 + (Math.random() - 0.5) * 2,
          life: 0.5,
          decay: 0.05,
          size: Math.random() * 2 + 1,
          color: '#ffff00'
        });
      }
    }
    
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.life -= particle.decay;
        particle.vx *= 0.98;
        particle.vy *= 0.98;
        
        if (particle.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }
    
    function showRespawnMessage() {
      const respawnDiv = document.getElementById('respawnMessage');
      const timerSpan = document.getElementById('respawnTimer');
      let timer = 2;
      
      respawnDiv.style.display = 'block';
      
      const countdown = setInterval(() => {
        timer--;
        timerSpan.textContent = timer;
        
        if (timer <= 0) {
          clearInterval(countdown);
          respawnDiv.style.display = 'none';
        }
      }, 1000);
    }
    
    function updateUI() {
      if (myPlayer) {
        document.getElementById('health').textContent = myPlayer.health;
        document.getElementById('score').textContent = myPlayer.score;
        document.getElementById('kills').textContent = myPlayer.kills;
        document.getElementById('deaths').textContent = myPlayer.deaths;
      }
      
      // Update player list
      const playerListDiv = document.getElementById('playerList');
      playerListDiv.innerHTML = '';
      
      const sortedPlayers = Object.values(gameState.players)
        .sort((a, b) => b.score - a.score);
      
      sortedPlayers.forEach(player => {
        const playerDiv = document.createElement('div');
        playerDiv.className = 'player-stat';
        
        const nameSpan = document.createElement('span');
        nameSpan.className = player.id === socket.id ? 'current-player' : 'player-name';
        nameSpan.textContent = player.id.substr(0, 8);
        
        const statsSpan = document.createElement('span');
        statsSpan.textContent = `${player.score} (${player.kills}/${player.deaths})`;
        
        playerDiv.appendChild(nameSpan);
        playerDiv.appendChild(statsSpan);
        playerListDiv.appendChild(playerDiv);
      });
    }
    
    // Drawing functions
    function drawPlayer(player) {
      ctx.save();
      
      if (player.health <= 0) {
        ctx.globalAlpha = 0.3;
      }
      
      // Player body
      ctx.fillStyle = player.color;
      ctx.shadowColor = player.color;
      ctx.shadowBlur = player.id === socket.id ? 20 : 10;
      
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
      ctx.fill();
      
      // Health bar
      if (player.health < 100 && player.health > 0) {
        const barWidth = player.size * 2;
        const barHeight = 4;
        
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#333';
        ctx.fillRect(player.x - barWidth/2, player.y - player.size - 10, barWidth, barHeight);
        
        ctx.fillStyle = player.health > 30 ? '#0f0' : '#f00';
        ctx.fillRect(player.x - barWidth/2, player.y - player.size - 10, 
                    (player.health / 100) * barWidth, barHeight);
      }
      
      // Player name
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#fff';
      ctx.font = '10px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(player.id.substr(0, 6), player.x, player.y + player.size + 15);
      
      ctx.restore();
    }
    
    function drawBullet(bullet) {
      ctx.save();
      ctx.fillStyle = '#ffff00';
      ctx.shadowColor = '#ffff00';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
    
    function drawPowerUp(powerUp) {
      ctx.save();
      
      const color = powerUp.type === 'health' ? '#0f0' : '#f0f';
      const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
      
      ctx.fillStyle = color;
      ctx.shadowColor = color;
      ctx.shadowBlur = 15 * pulse;
      ctx.globalAlpha = pulse;
      
      ctx.beginPath();
      ctx.arc(powerUp.x, powerUp.y, 12, 0, Math.PI * 2);
      ctx.fill();
      
      // Icon
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#fff';
      ctx.font = '16px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(powerUp.type === 'health' ? '+' : '!', powerUp.x, powerUp.y + 5);
      
      ctx.restore();
    }
    
    function drawParticles() {
      ctx.save();
      particles.forEach(particle => {
        ctx.globalAlpha = particle.life;
        ctx.fillStyle = particle.color;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.restore();
    }
    
    function drawBackground() {
      // Animated starfield
      ctx.save();
      ctx.fillStyle = '#fff';
      for (let i = 0; i < 150; i++) {
        const x = (i * 123) % canvas.width;
        const y = ((i * 456) + Date.now() * 0.01) % canvas.height;
        const size = Math.sin(i) * 0.5 + 0.5;
        ctx.globalAlpha = size * 0.7;
        ctx.beginPath();
        ctx.arc(x, y, 1, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }
    
    function drawCrosshair() {
      if (!myPlayer || myPlayer.health <= 0) return;
      
      ctx.save();
      ctx.strokeStyle = rightMouseDown ? '#f00' : '#0f0';
      ctx.lineWidth = 2;
      ctx.shadowColor = ctx.strokeStyle;
      ctx.shadowBlur = 5;
      
      const size = 10;
      ctx.beginPath();
      ctx.moveTo(mousePos.x - size, mousePos.y);
      ctx.lineTo(mousePos.x + size, mousePos.y);
      ctx.moveTo(mousePos.x, mousePos.y - size);
      ctx.lineTo(mousePos.x, mousePos.y + size);
      ctx.stroke();
      
      if (rightMouseDown) {
        // Draw auto-aim indicator
        let nearestEnemy = null;
        let nearestDistance = Infinity;
        
        Object.values(gameState.players).forEach(player => {
          if (player.id !== socket.id && player.health > 0) {
            const distance = Math.sqrt(
              Math.pow(myPlayer.x - player.x, 2) + Math.pow(myPlayer.y - player.y, 2)
            );
            
            if (distance < nearestDistance) {
              nearestDistance = distance;
              nearestEnemy = player;
            }
          }
        });
        
        if (nearestEnemy) {
          ctx.strokeStyle = '#ff0';
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(myPlayer.x, myPlayer.y);
          ctx.lineTo(nearestEnemy.x, nearestEnemy.y);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }
      
      ctx.restore();
    }
    
    // Main game loop
    function gameLoop() {
      updatePlayer();
      updateParticles();
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw everything
      drawBackground();
      drawParticles();
      
      // Draw power-ups
      gameState.powerUps.forEach(powerUp => {
        drawPowerUp(powerUp);
      });
      
      // Draw bullets
      gameState.bullets.forEach(bullet => {
        drawBullet(bullet);
      });
      
      // Draw players
      Object.values(gameState.players).forEach(player => {
        drawPlayer(player);
      });
      
      drawCrosshair();
      
      requestAnimationFrame(gameLoop);
    }
    
    // Start the game
    gameLoop();
  </script>
</body>
</html>